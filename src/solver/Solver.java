package solver;

import java.util.*;

/**
 * This class contains a universal algorithm to find a path from a starting
 * configuration to a solution, if one exists.
 * @author Damon Gonzalez
 */
public class Solver {
    /** The total amount of configs generated by this Solver, must be at least 1 after BFS() is run*/
    private int totalConfigs = 0;
    /** The amount of unique configurations, essentially the amount of valid ones the solver generated in its process, must also be at least 1 after BFS() is run */
    private int uniqueConfigs = 0;
    /**
     * This method will hold the BFS algorithm that can be used across all graph
     * related puzzles. It will be given a node(Configuration) in the graph to start with;
     * computing the path from there. When the algorithm terminates it will return a List representing
     * the shortest path between two nodes in the graph. If the List is empty, there is no path.
     * @param startConfig The initial Configuration
     * @return The path that is calculated
     */
    public List<Configuration> BFS(Configuration startConfig){
        List<Configuration> queue = new LinkedList<>();
        Map<Configuration, Configuration> predecessorMap = new HashMap<>();
        queue.add(startConfig);
        predecessorMap.put(startConfig, null);
        totalConfigs = 1;
        Configuration solution = null;
        while(queue.size() != 0){
            Configuration currentConfig = queue.remove(0);
            List<Configuration> neighbors = currentConfig.getNeighbors();
            if(currentConfig.isSolution()) {
                solution = currentConfig;
                queue.clear();
                break;
            }
            totalConfigs += neighbors.size();
            for (Configuration neighbor : neighbors){
                if(!predecessorMap.containsKey(neighbor)){
                    queue.add(neighbor);
                    predecessorMap.put(neighbor, currentConfig);
                }
            }
        }
        uniqueConfigs = predecessorMap.size();
        List<Configuration> path = new ArrayList<>();
        if(solution != null) {
            Configuration traversalConfig = solution;
            path.add(0, traversalConfig);
            while (!startConfig.equals(traversalConfig)) {
                traversalConfig = predecessorMap.get(traversalConfig);
                path.add(0, traversalConfig);
            }
        }
        return path;
    }

    /** Public getter for the total configurations generated by the BFS method, returns 0 if BFS() was not called */
    public int getTotalConfigs() { return totalConfigs; }
    /** Public getter for the amount of unique configurations generated by the BFS method, returns 0 if BFS() was not called */
    public int getUniqueConfigs() { return uniqueConfigs; }
}
